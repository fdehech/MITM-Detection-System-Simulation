\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{hmargin=2.5cm,vmargin=2.5cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\textbf{Rapport Technique : Système de Détection d'Attaques Man-in-the-Middle (MITM) sur Flux TCP}}
\author{Généré par l'Assistant IA}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
La sécurité des communications réseaux est un enjeu critique dans les infrastructures modernes. Les attaques de type \textit{Man-in-the-Middle} (MITM) représentent une menace majeure où un attaquant s'interpose secrètement entre deux parties pour intercepter ou modifier les échanges. Ce projet vise à développer un système expérimental capable de détecter ces attaques sur des flux TCP en analysant les anomalies de transmission telles que les délais, les pertes de paquets et le désordonnancement. L'objectif n'est pas la prévention, mais la détection active via une analyse comportementale du trafic.

\section{Objectifs et Portée du Projet}
Le projet se concentre sur la mise en œuvre d'une architecture client-serveur TCP instrumentée pour identifier les perturbations introduites par un proxy malveillant. Les objectifs spécifiques sont :
\begin{itemize}
    \item Établir une communication TCP fiable et structurée.
    \item Simuler un attaquant (Proxy MITM) capable d'altérer le trafic (délai, suppression, réorganisation).
    \item Implémenter des algorithmes de détection côté serveur.
    \item Assurer la reproductibilité via une conteneurisation Docker.
\end{itemize}

\section{Architecture Globale}
Le système repose sur une architecture modulaire composée de trois entités distinctes, chacune isolée dans un conteneur Docker :
\begin{enumerate}
    \item \textbf{Client TCP} : Génère un trafic légitime et structuré.
    \item \textbf{Proxy MITM} : Intercepte le trafic et injecte des anomalies selon le mode d'attaque configuré.
    \item \textbf{Serveur de Détection} : Analyse les paquets reçus pour identifier les signatures d'attaques.
\end{enumerate}
Les conteneurs communiquent via un réseau privé virtuel (\texttt{lab\_net}), garantissant un environnement contrôlé pour les expérimentations.

\section{Implémentation TCP en Python}
L'implémentation repose sur la bibliothèque standard \texttt{socket} de Python. Le protocole applicatif défini permet de suivre précisément l'état de la communication.

\subsection{Initialisation des Sockets}
\begin{lstlisting}[language=Python, caption=Connexion Client]
def connect(self):
    # Établissement de la connexion au proxy
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Création d'un socket
    self.socket.connect((self.host, self.port)) # Connexion au proxy
    self.logger.info(f"Connected to proxy at {self.host}:{self.port}")
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Initialisation Serveur]
# Création et configuration du socket serveur
self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
self.server_socket.bind((self.host, self.port))
self.server_socket.listen(1)
\end{lstlisting}

\subsection{Structure des Messages}
Chaque message envoyé par le client respecte un format strict facilitant l'analyse :
\begin{verbatim}
SEQ=<numéro>|TS=<timestamp>|DATA=<payload>
\end{verbatim}
\begin{itemize}
    \item \texttt{SEQ} : Numéro de séquence incrémental pour détecter les pertes et le désordre.
    \item \texttt{TS} : Horodatage (Unix timestamp) pour mesurer la latence.
    \item \texttt{DATA} : Charge utile arbitraire.
\end{itemize}

\subsection{Logique Client (\texttt{client.py})}
Le client maintient une connexion persistante et envoie des messages à intervalles réguliers.
\begin{lstlisting}[language=Python, caption=Création du message côté client]
def _create_message(self):
    timestamp = int(time.time())
    message = f"SEQ={self.sequence_number}|TS={timestamp}|DATA={self.payload}\n"
    return message
\end{lstlisting}

\subsection{Logique Serveur (\texttt{server.py})}
Le serveur écoute sur le port 9001 et traite chaque message reçu. Il extrait les métadonnées pour alimenter les algorithmes de détection.
\begin{lstlisting}[language=Python, caption=Parsing du message côté serveur]
def _parse_message(self, raw_message):
    parts = raw_message.split("|")
    fields = {}
    for part in parts:
        key, value = part.split("=", 1)
        fields[key] = value
    return Message(
        sequence=int(fields["SEQ"]),
        timestamp=int(fields["TS"]),
        payload=fields["DATA"]
    )
\end{lstlisting}

\section{Simulation MITM via Proxy}
Le composant central de la simulation est le proxy (\texttt{proxy.py}), qui agit comme un relais transparent ou malveillant. Il utilise le multi-threading pour gérer les communications bidirectionnelles (Client $\leftrightarrow$ Serveur).

\subsection{Logique de Transfert (Forwarding)}
Le cœur du proxy réside dans sa capacité à relayer le trafic tout en permettant l'injection d'anomalies.
\begin{lstlisting}[language=Python, caption=Boucle de transfert du Proxy]
def _forward(self, source, destination, direction):
    """Forward data from source to destination with optional manipulation."""
    # Create a local buffer for this direction if in reorder mode
    buffer = deque(maxlen=self.reorder_window) if self.mode == AttackMode.REORDER else None
    
    try:
        while True:
            data = source.recv(self.buffer_size)
            if not data:
                break
            
            # Process data according to attack mode
            processed = self._process_data(data, buffer)
            
            # If processed is None, packet is dropped or buffered
            if processed is not None:
                destination.sendall(processed)
                self.logger.info(f"{direction}: forwarded {len(processed)} bytes")
    except Exception as e:
        self.logger.info(f"{direction}: stopped ({e})")
    finally:
        # Flush reorder buffer if in reorder mode
        if self.mode == AttackMode.REORDER and buffer:
            while buffer:
                try:
                    destination.sendall(buffer.popleft())
                except:
                    pass
\end{lstlisting}

\subsection{Modes d'Attaque}
Le proxy implémente plusieurs comportements malveillants configurables :
\begin{itemize}
    \item \textbf{Transparent} : Relai passif sans modification.
    \item \textbf{Random Delay} : Introduction d'une latence aléatoire pour simuler une congestion ou une analyse profonde.
    \item \textbf{Drop} : Suppression aléatoire de paquets (déni de service partiel).
    \item \textbf{Reorder} : Mise en tampon et envoi désordonné des paquets.
\end{itemize}

\begin{lstlisting}[language=Python, caption=Logique de délai aléatoire dans le proxy]
elif self.mode == AttackMode.RANDOM_DELAY:
    delay = random.uniform(self.delay_min, self.delay_max)
    self.logger.warning(f"MODE = Random Delay -> delaying {delay:.2f}s")
    time.sleep(delay)
    return data
\end{lstlisting}

\section{Conteneurisation Docker}
L'utilisation de Docker assure la portabilité et l'isolation du réseau. Le fichier \texttt{docker-compose.yml} orchestre les trois services.

\subsection{Configuration Réseau}
Les services sont connectés au réseau \texttt{lab\_net} (driver \texttt{bridge}).
\begin{itemize}
    \item \texttt{tcp\_server} : Écoute sur le port 9001.
    \item \texttt{tcp\_proxy} : Écoute sur le port 9000 et redirige vers \texttt{tcp\_server:9001}.
    \item \texttt{tcp\_client} : Se connecte à \texttt{tcp\_proxy:9000}.
\end{itemize}
Cette topologie force le trafic du client à traverser le proxy avant d'atteindre le serveur.

\section{Gestion de la Configuration (.env)}
La flexibilité du système repose sur l'utilisation de variables d'environnement, centralisées dans un fichier \texttt{.env}. Cela permet de modifier les paramètres de simulation sans recompilation.

Paramètres clés :
\begin{itemize}
    \item \texttt{PROXY\_MODE} : Mode d'attaque (\texttt{transparent}, \texttt{random\_delay}, \texttt{drop}, \texttt{reorder}).
    \item \texttt{PROXY\_DROP\_RATE} : Probabilité de perte de paquet.
    \item \texttt{SERVER\_MAX\_DELAY} : Seuil de tolérance pour la détection de latence.
\end{itemize}

\begin{lstlisting}[caption=Exemple de fichier .env]
PROXY_MODE=random_delay
PROXY_DELAY_MIN=2.0
PROXY_DELAY_MAX=5.0
PROXY_DROP_RATE=0.3
SERVER_MAX_DELAY=3.0
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Chargement de la configuration (Proxy)]
# Lecture de la configuration des variables d'environnement
proxy_host = os.getenv("PROXY_LISTEN_HOST", "0.0.0.0")
proxy_port = int(os.getenv("PROXY_LISTEN_PORT", "9000"))
server_host = os.getenv("PROXY_SERVER_HOST", "server")
server_port = int(os.getenv("PROXY_SERVER_PORT", "9001"))
mode = os.getenv("PROXY_MODE", "transparent")
\end{lstlisting}

\section{Logique de Détection et Alertes}
Le serveur implémente trois mécanismes principaux de détection basés sur l'analyse des métadonnées du protocole.

\begin{lstlisting}[language=Python, caption=Orchestration de la détection]
def _process_message(self, raw_message):
    """ Algorithme de traitement et d'analyse des messages arrivés"""
    if self._detect_integrity_violation(raw_message):
        return
    try:
        message = self._parse_message(raw_message) 
        
        # Algorithme de détection (seulement si activé)
        if os.getenv("SERVER_DETECTION_ENABLED", "true").lower() == "true":
            self._detect_reorder_attack(message.sequence)
            self._detect_dropped_packets(message.sequence)
            self._detect_delay_attack(message.timestamp)
        
        delay = int(time.time()) - message.timestamp
        self.logger.info(
            f"SEQ={message.sequence} | TS={message.timestamp} | Delay={delay}s | DATA={message.payload}"
        )
    except Exception as e:
        self.logger.error(f"Error processing message: {e}")
\end{lstlisting}

\subsection{Détection de Latence (Delay Attack)}
Le serveur compare le timestamp d'envoi (\texttt{TS}) avec l'heure de réception. Si la différence excède \texttt{SERVER\_MAX\_DELAY}, une alerte est levée.
\begin{lstlisting}[language=Python, caption=Détection de latence]
def _detect_delay_attack(self, timestamp):
    current_time = int(time.time())
    delay = current_time - timestamp
    if delay > self.max_delay:
        self.logger.critical(f"[ALERT] DELAY ATTACK DETECTED")
        return True
\end{lstlisting}

\subsection{Détection de Perte de Paquets (Drop Attack)}
Le serveur surveille la continuité des numéros de séquence (\texttt{SEQ}). Un saut dans la numérotation indique une perte de paquet.
\begin{lstlisting}[language=Python, caption=Détection des paquets perdus]
def _detect_dropped_packets(self, sequence):
    """ Détection des paquets perdus """
    if sequence > self.expected_sequence:
        # Gap detected - packets were dropped
        missing_range = list(range(self.expected_sequence, sequence))
        self.logger.critical(
            f"[ALERT] DROPPED PACKETS DETECTED: Missing sequence numbers {missing_range}"
        )
        self.expected_sequence = sequence + 1
        return True
\end{lstlisting}

\subsection{Détection de Désordre (Reorder Attack)}
Si un numéro de séquence reçu est inférieur au numéro attendu, cela signifie que les paquets sont arrivés dans le désordre.
\begin{lstlisting}[language=Python, caption=Détection des paquets réordonnés]
def _detect_reorder_attack(self, sequence):
    """ Détection des paquets reordonnés """
    if sequence < self.expected_sequence:
        self.logger.critical(
            f"[ALERT] OUT-OF-ORDER PACKET: Received SEQ={sequence}, Expected SEQ={self.expected_sequence}"
        )
        return True
    return False
\end{lstlisting}

\section{Limitations et Perspectives}
Bien que fonctionnel, ce système présente certaines limitations :
\begin{itemize}
    \item \textbf{Absence de Chiffrement} : Le protocole est en clair, ce qui facilite l'analyse mais ne reflète pas les communications sécurisées (TLS).
    \item \textbf{Détection Basique} : Les seuils fixes (ex: \texttt{MAX\_DELAY}) peuvent générer des faux positifs en cas de congestion réseau légitime.
\end{itemize}
Les évolutions futures pourraient inclure l'intégration de TLS, une détection statistique plus robuste, et une interface de visualisation en temps réel (Dashboard).

\section{Conclusion}
Ce projet démontre la faisabilité de la détection d'attaques MITM par l'analyse comportementale des flux TCP. L'architecture modulaire basée sur Docker et Python permet de simuler efficacement divers scénarios d'attaque et de valider les mécanismes de défense. Il constitue une base solide pour l'étude approfondie de la sécurité des réseaux.

\end{document}
